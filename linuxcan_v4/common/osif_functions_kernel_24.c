/*
** Copyright 2002-2006 KVASER AB, Sweden.  All rights reserved.
*/

//--------------------------------------------------
// NOTE! module_versioning HAVE to be included first
#include "module_versioning.h"
//--------------------------------------------------

#   include <linux/version.h>
#   include <linux/slab.h>
#   include <linux/sched.h>
#   include <linux/interrupt.h>
#   include <asm/io.h>
#   include <asm/system.h>
#   include <asm/bitops.h>
#   include <asm/uaccess.h>
#   include <linux/tqueue.h>

// Common
#include "osif_kernel.h"
#include "osif_functions_kernel.h"
#include "debug.h"


//////////////////////////////////////////////////////////////////////
// os_if_write_port
// write to port
//////////////////////////////////////////////////////////////////////
void os_if_write_port (unsigned regist, unsigned portAddr)
{
  outb(regist, portAddr);
}

//////////////////////////////////////////////////////////////////////
// os_if_read_port
// read from port
//////////////////////////////////////////////////////////////////////
unsigned int os_if_read_port (unsigned portAddr)
{
  return inb(portAddr);
}

//////////////////////////////////////////////////////////////////////
// os_if_queue_task
// put task to queue/set event
//////////////////////////////////////////////////////////////////////
int os_if_queue_task (OS_IF_TASK_QUEUE_HANDLE *hnd)
{
  int ret = queue_task(hnd, &tq_immediate);
  mark_bh(IMMEDIATE_BH);
  return ret;
}

//////////////////////////////////////////////////////////////////////
// os_if_queue_task_not_default_queue
// put task to queue/set event
//////////////////////////////////////////////////////////////////////
int os_if_queue_task_not_default_queue (OS_IF_WQUEUE *wq,
                                        OS_IF_TASK_QUEUE_HANDLE *hnd)
{
  int ret = queue_task(hnd, &tq_immediate);
  mark_bh(IMMEDIATE_BH);
  return ret;
}



//////////////////////////////////////////////////////////////////////
// os_if_init_waitqueue_head
//
//////////////////////////////////////////////////////////////////////
void os_if_init_waitqueue_head (OS_IF_WAITQUEUE_HEAD *handle)
{
  init_waitqueue_head(handle);
}


//////////////////////////////////////////////////////////////////////
// os_if_init_named_waitqueue_head
//
//////////////////////////////////////////////////////////////////////
void os_if_init_named_waitqueue_head (OS_IF_WAITQUEUE_HEAD *handle, char *name)
{
  init_waitqueue_head(handle);
}


//////////////////////////////////////////////////////////////////////
// os_if_delete_waitqueue_head
//
//////////////////////////////////////////////////////////////////////
void os_if_delete_waitqueue_head (OS_IF_WAITQUEUE_HEAD *handle)
{
}


//////////////////////////////////////////////////////////////////////
// os_if_init_waitqueue_entry
//
//////////////////////////////////////////////////////////////////////
void os_if_init_waitqueue_entry (OS_IF_WAITQUEUE *wait)
{
  init_waitqueue_entry(wait, current);
}


//////////////////////////////////////////////////////////////////////
// os_if_add_wait_queue
//
//////////////////////////////////////////////////////////////////////
void os_if_add_wait_queue (OS_IF_WAITQUEUE_HEAD *waitQ, OS_IF_WAITQUEUE *wait)
{
  add_wait_queue(waitQ, wait);
}


//////////////////////////////////////////////////////////////////////
// os_if_remove_wait_queue
//
//////////////////////////////////////////////////////////////////////
void os_if_remove_wait_queue (OS_IF_WAITQUEUE_HEAD *waitQ, OS_IF_WAITQUEUE *wait)
{
  remove_wait_queue(waitQ, wait);
}


//////////////////////////////////////////////////////////////////////
// os_if_wait_for_event_timeout
//
//////////////////////////////////////////////////////////////////////
signed long os_if_wait_for_event_timeout (signed long timeout,
                                          OS_IF_WAITQUEUE *handle)
{
  return schedule_timeout(msecs_to_jiffies(timeout) + 1);
}

//////////////////////////////////////////////////////////////////////
// os_if_schedule_timeout_simple
//
//////////////////////////////////////////////////////////////////////
signed long os_if_wait_for_event_timeout_simple (signed long timeout)
{
  return schedule_timeout(msecs_to_jiffies(timeout) + 1);
}

//////////////////////////////////////////////////////////////////////
// os_if_schedule
//
//////////////////////////////////////////////////////////////////////
void os_if_wait_for_event (OS_IF_WAITQUEUE_HEAD *handle)
{
  schedule();
}

//////////////////////////////////////////////////////////////////////
// os_if_wake_up_interruptible
//
//////////////////////////////////////////////////////////////////////
void os_if_wake_up_interruptible (OS_IF_WAITQUEUE_HEAD *handle)
{
  wake_up_interruptible(handle);
}

//////////////////////////////////////////////////////////////////////
// os_if_up_sema
//
//////////////////////////////////////////////////////////////////////
void os_if_up_sema (OS_IF_SEMAPHORE *var)
{
  up(var);
}

//////////////////////////////////////////////////////////////////////
// os_if_down_sema
//
//////////////////////////////////////////////////////////////////////
void os_if_down_sema (OS_IF_SEMAPHORE *var)
{
  down(var);
}

//////////////////////////////////////////////////////////////////////
// os_if_init_sema
//
//////////////////////////////////////////////////////////////////////
void os_if_init_sema (OS_IF_SEMAPHORE *var)
{
  sema_init(var, 0);
}

//////////////////////////////////////////////////////////////////////
// os_if_delete_sema
//
//////////////////////////////////////////////////////////////////////
void os_if_delete_sema (OS_IF_SEMAPHORE *var)
{
}


//////////////////////////////////////////////////////////////////////
// Time management functions
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// os_if_get_timeout_time
//
//////////////////////////////////////////////////////////////////////
unsigned long os_if_get_timeout_time (void)
{
  return jiffies + 1 * HZ;
}

//////////////////////////////////////////////////////////////////////
// os_if_do_get_time_of_day
//
//////////////////////////////////////////////////////////////////////
void os_if_do_get_time_of_day (OS_IF_TIME_VAL *tv)
{
  do_gettimeofday(tv);
}

//////////////////////////////////////////////////////////////////////
// os_if_is_rec_busy
//
//////////////////////////////////////////////////////////////////////
int os_if_is_rec_busy (int nr, volatile unsigned long *addr)
{
  return test_and_set_bit(nr, addr);
}

//////////////////////////////////////////////////////////////////////
// os_if_rec_not_busy
//
//////////////////////////////////////////////////////////////////////
void os_if_rec_not_busy (int nr, volatile unsigned long *addr)
{
  return clear_bit(nr, addr);
}

//////////////////////////////////////////////////////////////////////
// Spin locks
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// os_if_spin_lock_init
//
//////////////////////////////////////////////////////////////////////
void os_if_spin_lock_init (OS_IF_LOCK *lock)
{
  spin_lock_init(lock);
}

//////////////////////////////////////////////////////////////////////
// os_if_spin_lock
//
//////////////////////////////////////////////////////////////////////
void os_if_spin_lock (OS_IF_LOCK *lock)
{
  spin_lock(lock);
}

//////////////////////////////////////////////////////////////////////
// os_if_spin_unlock
//
//////////////////////////////////////////////////////////////////////
void os_if_spin_unlock (OS_IF_LOCK *lock)
{
  spin_unlock(lock);
}

//////////////////////////////////////////////////////////////////////
// os_if_spin_lock_remove
//
//////////////////////////////////////////////////////////////////////
void os_if_spin_lock_remove (OS_IF_LOCK *lock)
{
  DeleteCriticalSection(lock);
}

//////////////////////////////////////////////////////////////////////
// Interrupts
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// os_if_irq_disable
//
//////////////////////////////////////////////////////////////////////
void os_if_irq_disable (OS_IF_LOCK *lock)
{
// qqq spin_lock should work for 2_4 too!
  cli();
}

//////////////////////////////////////////////////////////////////////
// os_if_irq_enable
//
//////////////////////////////////////////////////////////////////////
void os_if_irq_enable (OS_IF_LOCK *lock)
{
  // qqq spin_lock should work for 2_4 too!
  sti();
}

//////////////////////////////////////////////////////////////////////
// os_if_irq_save
//
//////////////////////////////////////////////////////////////////////
void os_if_irq_save (OS_IF_LOCK *lock, unsigned long *flags)
{
  // Not needed in 2_4
}

//////////////////////////////////////////////////////////////////////
// os_if_irq_restore
//
//////////////////////////////////////////////////////////////////////
void os_if_irq_restore (OS_IF_LOCK *lock, unsigned long flags)
{
  // Not needed in 2_4
}

//////////////////////////////////////////////////////////////////////
// os_if_spin_lock_irqsave
//
//////////////////////////////////////////////////////////////////////
void os_if_spin_lock_irqsave (OS_IF_LOCK *lock, unsigned long *flags)
{
  spin_lock_irqsave(lock, *flags);
}

//////////////////////////////////////////////////////////////////////
// os_if_spin_unlock_irqrestore
//
//////////////////////////////////////////////////////////////////////
void os_if_spin_unlock_irqrestore (OS_IF_LOCK *lock, unsigned long flags)
{
  spin_unlock_irqrestore(lock, flags);
}

//////////////////////////////////////////////////////////////////////
// os_if_spin_lock_softirq
//
//////////////////////////////////////////////////////////////////////
void os_if_spin_lock_softirq (OS_IF_LOCK *lock)
{
  spin_lock_bh(lock);
}

//////////////////////////////////////////////////////////////////////
// os_if_spin_unlock_softirq
//
//////////////////////////////////////////////////////////////////////
void os_if_spin_unlock_softirq (OS_IF_LOCK *lock)
{
  spin_unlock_bh(lock);
}

//////////////////////////////////////////////////////////////////////
// Data transfer between user and kernel space
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// os_if_get_user_data
//
//////////////////////////////////////////////////////////////////////
int os_if_get_user_data (void *to, const void *from, OS_IF_SIZE n)
{
  return copy_to_user(to, from, n);
}

//////////////////////////////////////////////////////////////////////
// os_if_set_user_data
//
//////////////////////////////////////////////////////////////////////
int os_if_set_user_data (void *to, const void *from, OS_IF_SIZE n)
{
  return copy_from_user(to, from, n);
}

//////////////////////////////////////////////////////////////////////
// os_if_set_int
//
//////////////////////////////////////////////////////////////////////
int os_if_set_int (int val, int *dest)
{
  return put_user(val, dest);
}

//////////////////////////////////////////////////////////////////////
// os_if_get_int
//
//////////////////////////////////////////////////////////////////////
int os_if_get_int (int *val, int *src)
{
  return get_user(*val, src);
}

//////////////////////////////////////////////////////////////////////
// os_if_get_long
//
//////////////////////////////////////////////////////////////////////
int os_if_get_long (long *val, long *src)
{
  return get_user(*val, src);
}



//////////////////////////////////////////////////////////////////////
// Task management functions
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// os_if_declare_task
//
//////////////////////////////////////////////////////////////////////
OS_IF_WQUEUE* os_if_declare_task (char *name, OS_IF_TASK_QUEUE_HANDLE *taskQ)
{
  return 0;
}

//////////////////////////////////////////////////////////////////////
// os_if_destroy_task
//
//////////////////////////////////////////////////////////////////////
void os_if_destroy_task (OS_IF_WQUEUE *wQueue)
{
}

//////////////////////////////////////////////////////////////////////
// os_if_init_task
//
//////////////////////////////////////////////////////////////////////
void os_if_init_task (OS_IF_TASK_QUEUE_HANDLE *taskQ, void *function, void *data)
{
  taskQ->routine  = function;
  taskQ->data     = data;
}

//////////////////////////////////////////////////////////////////////
// os_if_set_task_interruptible
//
//////////////////////////////////////////////////////////////////////
void os_if_set_task_interruptible (void)
{
  set_current_state(TASK_INTERRUPTIBLE);
}

//////////////////////////////////////////////////////////////////////
// os_if_set_task_uninterruptible
//
//////////////////////////////////////////////////////////////////////
void os_if_set_task_uninterruptible (void)
{
  set_current_state(TASK_UNINTERRUPTIBLE);
}

//////////////////////////////////////////////////////////////////////
// os_if_set_task_running
//
//////////////////////////////////////////////////////////////////////
void os_if_set_task_running (void)
{
  set_current_state(TASK_RUNNING);
}

//////////////////////////////////////////////////////////////////////
// Read and write locks
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// os_if_rwlock_init
//
//////////////////////////////////////////////////////////////////////
void os_if_rwlock_init (rwlock_t *lock)
{
  // Do nothing
}

//////////////////////////////////////////////////////////////////////
// os_if_read_lock_irqsave
//
//////////////////////////////////////////////////////////////////////
void os_if_read_lock_irqsave (rwlock_t *rw_lock, unsigned long *flags)
{
  // Do nothing
}

//////////////////////////////////////////////////////////////////////
// os_if_read_unlock_irqrestore
//
//////////////////////////////////////////////////////////////////////
void os_if_read_unlock_irqrestore (rwlock_t *rw_lock, unsigned long flags)
{
  // Do nothing
}

//////////////////////////////////////////////////////////////////////
// os_if_write_lock_irqsave
//
//////////////////////////////////////////////////////////////////////
void os_if_write_lock_irqsave (rwlock_t *rw_lock, unsigned long *flags)
{
  // Do nothing
}

//////////////////////////////////////////////////////////////////////
// os_if_write_unlock_irqrestore
//
//////////////////////////////////////////////////////////////////////
void os_if_write_unlock_irqrestore (rwlock_t *rw_lock, unsigned long flags)
{
  // Do nothing
}

//////////////////////////////////////////////////////////////////////
// os_if_rwlock_remove
//
//////////////////////////////////////////////////////////////////////
void os_if_rwlock_remove (rwlock_t *lock)
{
}

//////////////////////////////////////////////////////////////////////
// System signals
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// os_if_signal_pending
//
//////////////////////////////////////////////////////////////////////
int os_if_signal_pending(void)
{
  return signal_pending(current);
}


//////////////////////////////////////////////////////////////////////
// Memory allocation functions
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// os_if_kernel_malloc
//
//////////////////////////////////////////////////////////////////////
void *os_if_kernel_malloc (size_t buffer_size)
{
  return kmalloc(buffer_size, GFP_KERNEL);
}

//////////////////////////////////////////////////////////////////////
// os_if_kernel_free
//
//////////////////////////////////////////////////////////////////////
void os_if_kernel_free (void *mem_ptr)
{
  kfree(mem_ptr);
}

//////////////////////////////////////////////////////////////////////
// Thread management functions
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// os_if_remove_thread
//
//////////////////////////////////////////////////////////////////////
void os_if_remove_thread (OS_IF_THREAD thread)
{
}

//////////////////////////////////////////////////////////////////////
// os_if_exit_thread
//
//////////////////////////////////////////////////////////////////////
void os_if_exit_thread (int result)
{
}
